using System.Reflection;
using System;
using System.IO;
using Microsoft.Extensions.DependencyModel;
using System.Linq;
using CotorraNode.Common.Config;
using Microsoft.Extensions.PlatformAbstractions;
using Microsoft.Extensions.DependencyModel.Resolution;
using System.Collections.Generic;
using System.Runtime.Loader;
using Cotorra.Schema;

namespace Cotorra.Client
{
    //------------------------------------------------------------------------------
    // <auto-generated>
    //    Este código se generó a partir de una plantilla.
    // No se sobreescribirán los cambios manuales si se regenera el código
    // </auto-generated>
    //------------------------------------------------------------------------------


    //Factory for client adapters
    /// <summary>
    /// 
    /// </summary>
    public class ClientAdapterFactory2
    {

        #region normal

        /// <summary>
        /// Gets the instance.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="clientType">Type of the client.</param>
        /// <param name="authorizationHeader">The authorization header.</param>
        /// <param name="clientadapter">The clientadapter.</param>
        /// <returns></returns>
        public static T GetInstance<T>(Type clientType, string authorizationHeader, ClientConfiguration.ClientAdapter clientadapter = ClientConfiguration.ClientAdapter.Proxy)
        where T : class
        {
            return GetInstanceAsembly<T>(clientType, authorizationHeader, config: null, clientadapter: clientadapter);
        }


        /// <summary>
        /// Gets the instance.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="clientType">Type of the client.</param>
        /// <param name="authorizationHeader">The authorization header.</param>
        /// <param name="config">The configuration.</param>
        /// <param name="clientadapter">The clientadapter.</param>
        /// <returns></returns>
        public static T GetInstance<T>(Type clientType, string authorizationHeader, IConfigProvider config,
            ClientConfiguration.ClientAdapter clientadapter = ClientConfiguration.ClientAdapter.Proxy) where T : class
        {
            return GetInstanceAsembly<T>(clientType, authorizationHeader, config: config, clientadapter: clientadapter);
        }

        /// <summary>
        /// Gets the instance asembly.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="clientType">Type of the client.</param>
        /// <param name="authorizationHeader">The authorization header.</param>
        /// <param name="config">The configuration.</param>
        /// <param name="clientadapter">The clientadapter.</param>
        /// <returns></returns>
        /// <exception cref="InvalidOperationException">Client adapter not found</exception>
        private static T GetInstanceAsembly<T>(Type clientType, string authorizationHeader, IConfigProvider config = null,
             ClientConfiguration.ClientAdapter clientadapter = ClientConfiguration.ClientAdapter.Proxy) where T : class
        {
            Assembly assembly = null;
            var variable = PlatformServices.Default.Application.ApplicationBasePath;
            Type type = null;
            try
            {
                if (clientadapter == ClientConfiguration.ClientAdapter.Proxy)
                {
                    assembly = Assembly.LoadFrom(variable + "Cotorra.ClientProxy.dll");
                }
                else if (clientadapter == ClientConfiguration.ClientAdapter.Local)
                {
                    assembly = Assembly.LoadFrom(variable + "Cotorra.ClientLocal.dll");
                }
                else if (clientadapter == ClientConfiguration.ClientAdapter.Internal)
                {
                    assembly = Assembly.LoadFrom(variable + "Cotorra.ClientLocal.dll");
                }
                if (assembly != null)
                {
                    type = assembly.GetType(clientType.FullName + clientadapter.ToString());

                }
                else
                {
                    throw new CotorraException(100, "100", "assembly is null", null);
                }

                if (config != null)
                {
                    return Activator.CreateInstance(type, authorizationHeader, config) as T;
                }
                else
                {
                    return Activator.CreateInstance(type, authorizationHeader) as T;
                }
            }
            catch (Exception)
            {
                return GetInstanceContext<T>(clientType, authorizationHeader, config, clientadapter);
            }

        }


        private static T GetInstanceContext<T>(Type clientType, string authorizationHeader, IConfigProvider configProvider,
                 ClientConfiguration.ClientAdapter clientadapter = ClientConfiguration.ClientAdapter.Proxy) where T : class
        {

            try
            {
                if (clientadapter == ClientConfiguration.ClientAdapter.Proxy)
                {
                    var runtime = DependencyContext.Default.RuntimeLibraries.FirstOrDefault(x => x.Name.Contains("CotorraNube.CotoRRA.ClientProxy"));
                    var assembly = Assembly.Load(new AssemblyName(runtime.Name));
                    Type type = assembly.GetType(clientType.FullName + clientadapter.ToString());
                    return Activator.CreateInstance(type, authorizationHeader, configProvider) as T;
                }
                else
                {
                    throw new NotSupportedException("Esta opraciòn solo esta soportada para clientes proxy");
                }
            }
            catch (Exception)
            {
                if (clientadapter == ClientConfiguration.ClientAdapter.Proxy)
                {
                    return GetInstanceContextPackageAssemblyNong<T>(clientType, authorizationHeader, configProvider: null, clientadapter: ClientConfiguration.ClientAdapter.Proxy);
                }
            }
            return null;
        }

        private static T GetInstanceContextPackageAssemblyNong<T>(Type clientType, string authorizationHeader, IConfigProvider configProvider,
              ClientConfiguration.ClientAdapter clientadapter = ClientConfiguration.ClientAdapter.Proxy) where T : class
        {
            try
            {
                var appDirecotry = PlatformServices.Default.Application.ApplicationBasePath;
                var appName = PlatformServices.Default.Application.ApplicationName + ".dll";
                var direcotry = appDirecotry + appName;
                var info2 = DependencyContext.Default.RuntimeLibraries.FirstOrDefault(x => x.Name.Contains("CotorraNube.CotoRRA.Standard.ProxyClient"));
                var Assembly = AssemblyLoadContext.Default.LoadFromAssemblyPath(direcotry);

                var assemblyResolver = new CompositeCompilationAssemblyResolver
                                        (new ICompilationAssemblyResolver[]
                {
            new AppBaseCompilationAssemblyResolver(Path.GetDirectoryName(direcotry)),
            new ReferenceAssemblyPathResolver(),
            new PackageCompilationAssemblyResolver()
                });

                var loadContext = AssemblyLoadContext.GetLoadContext(Assembly);

                if (info2 != null)
                {
                    var wrapper = new CompilationLibrary(
                        info2.Type,
                        info2.Name,
                        info2.Version,
                        info2.Hash,
                        info2.RuntimeAssemblyGroups.SelectMany(g => g.AssetPaths),
                        info2.Dependencies,
                        info2.Serviceable);

                    var assemblies = new List<string>();
                    assemblyResolver.TryResolveAssemblyPaths(wrapper, assemblies);
                    if (assemblies.Count > 0)
                    {
                        var res = loadContext.LoadFromAssemblyPath(assemblies[0]);
                        Type type = res.GetType(clientType.FullName + clientadapter.ToString());
                        if (configProvider != null)
                        {
                            return Activator.CreateInstance(type, authorizationHeader, configProvider) as T;
                        }
                        else
                        {
                            return Activator.CreateInstance(type, authorizationHeader) as T;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException("Client adapter not found", ex);
            }

            return null;
        }
    }
    #endregion
}
